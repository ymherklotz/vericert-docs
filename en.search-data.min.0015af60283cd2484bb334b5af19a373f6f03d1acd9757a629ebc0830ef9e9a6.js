'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/building/','title':"Building Vericert",'section':"Docs",'content':"To build Vericert, the provided Makefile can be used. External dependencies are needed to build the project, which can be pulled in automatically with nix using the provided default.nix and shell.nix files.\nThe project is written in Coq, a theorem prover, which is extracted to OCaml so that it can then be compiled and executed. The dependencies of this project are the following:\n Coq: theorem prover that is used to also program the HLS tool. OCaml: the OCaml compiler to compile the extracted files. bbv: an efficient bit vector library. dune: build tool for ocaml projects to gather all the ocaml files and compile them in the right order. menhir: parser generator for ocaml. findlib to find installed OCaml libraries. GCC: compiler to help build CompCert.  These dependencies can be installed manually, or automatically through Nix.\nDefinition help := 0. Downloading CompCert #  CompCert is added as a submodule in the lib/CompCert directory. It is needed to run the build process below, as it is the one dependency that is not downloaded by nix, and has to be downloaded together with the repository. To clone CompCert together with this project, you can run:\ngit clone --recursive https://github.com/ymherklotz/vericert If the repository is already cloned, you can run the following command to make sure that CompCert is also downloaded:\ngit submodule update --init Setting up Nix #  Nix is a package manager that can create an isolated environment so that the builds are reproducible. Once nix is installed, it can be used in the following way.\nTo open a shell which includes all the necessary dependencies, one can use:\nnix-shell which will open a shell that has all the dependencies loaded.\nMakefile build #  If the dependencies were installed manually, or if one is in the nix-shell, the project can be built by running:\nmake -j8 and installed locally, or under the PREFIX location using:\nmake install Which will install the binary in ./bin/vericert by default. However, this can be changed by changing the PREFIX environment variable, in which case the binary will be installed in $PREFIX/bin/vericert.\nTesting #  To test out vericert you can try the following examples which are in the test folder using the following:\n./bin/vericert test/loop.c -o loop.v ./bin/vericert test/conditional.c -o conditional.v ./bin/vericert test/add.c -o add.v Or by running the test suite using the following command:\nmake test "});index.add({'id':1,'href':'/docs/','title':"Docs",'section':"Vericert",'content':"Vericert translates C code into a hardware description language called Verilog, which can then be synthesised into hardware, to be placed onto a field-programmable gate array (FPGA) or application-specific integrated circuit (ASIC).\n\n  Figure 1: Current design of Vericert, where HTL is an intermediate language representing a finite state machine with data-path (FSMD) and Verilog is the target language.\n  The design shown in Figure 1 shows how Vericert leverages an existing verified C compiler called CompCert to perform this translation.\n"});index.add({'id':2,'href':'/docs/using-vericert/','title':"Using Vericert",'section':"Docs",'content':"Vericert can be used to translate a subset of C into Verilog.\n"});})();