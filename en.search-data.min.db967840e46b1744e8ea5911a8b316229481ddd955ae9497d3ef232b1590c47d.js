'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/building/','title':"Building Vericert",'section':"Docs",'content':"To build Vericert, the provided Makefile can be used. External dependencies are needed to build the project, which can be pulled in automatically with nix using the provided default.nix and shell.nix files.\nThe project is written in Coq, a theorem prover, which is extracted to OCaml so that it can then be compiled and executed. The dependencies of this project are the following:\n Coq: theorem prover that is used to also program the HLS tool. OCaml: the OCaml compiler to compile the extracted files. bbv: an efficient bit vector library. dune: build tool for ocaml projects to gather all the ocaml files and compile them in the right order. menhir: parser generator for ocaml. findlib to find installed OCaml libraries. GCC: compiler to help build CompCert.  These dependencies can be installed manually, or automatically through Nix.\nDownloading CompCert #  CompCert is added as a submodule in the lib/CompCert directory. It is needed to run the build process below, as it is the one dependency that is not downloaded by nix, and has to be downloaded together with the repository. To clone CompCert together with this project, you can run:\ngit clone --recursive https://github.com/ymherklotz/vericert If the repository is already cloned, you can run the following command to make sure that CompCert is also downloaded:\ngit submodule update --init Setting up Nix #  Nix is a package manager that can create an isolated environment so that the builds are reproducible. Once nix is installed, it can be used in the following way.\nTo open a shell which includes all the necessary dependencies, one can use:\nnix-shell which will open a shell that has all the dependencies loaded.\nMakefile build #  If the dependencies were installed manually, or if one is in the nix-shell, the project can be built by running:\nmake -j8 and installed locally, or under the PREFIX location using:\nmake install Which will install the binary in ./bin/vericert by default. However, this can be changed by changing the PREFIX environment variable, in which case the binary will be installed in $PREFIX/bin/vericert.\nTesting #  To test out vericert you can try the following examples which are in the test folder using the following:\n./bin/vericert test/loop.c -o loop.v ./bin/vericert test/conditional.c -o conditional.v ./bin/vericert test/add.c -o add.v Or by running the test suite using the following command:\nmake test "});index.add({'id':1,'href':'/coq-style-guide/','title':"Coq Style Guide",'section':"Vericert",'content':"This style guide was taken from Silveroak, it outlines code style for Coq code in this repository. There are certainly other valid strategies and opinions on Coq code style; this is laid out purely in the name of consistency. For a visual example of the style, see the example at the bottom of this file.\nCode organization #  Legal banner #   Files should begin with a copyright/license banner, as shown in the example above.  Import statements #    Require Import statements should all go at the top of the file, followed by file-wide Import statements.\n =Import=s often contain notations or typeclass instances that might override notations or instances from another library, so it\u0026rsquo;s nice to highlight them separately.    One Require Import statement per line; it\u0026rsquo;s easier to scan that way.\n  Require Import statements should use \u0026ldquo;fully-qualified\u0026rdquo; names (e.g. =Require Import Coq.ZArith.ZArith= instead of Require Import ZArith).\n Use the Locate command to find the fully-qualified name!    Require Import\u0026rsquo;s should go in the following order:\n Standard library dependencies (start with Coq.) External dependencies (anything outside the current project) Same-project dependencies    Require Import\u0026rsquo;s with the same root library (the name before the first .) should be grouped together. Within each root-library group, they should be in alphabetical order (so Coq.Lists.List before Coq.ZArith.ZArith).\n  Notations and scopes #    Any file-wide Local Open Scope\u0026rsquo;s should come immediately after the =Import=s (see example).\n Always use Local Open Scope; just Open Scope will sneakily open the scope for those who import your file.    Put notations in their own separate modules or files, so that those who import your file can choose whether or not they want the notations.\n Conflicting notations can cause a lot of headache, so it comes in very handy to leave this flexibility!    Formatting #  Line length #   Maximum line length 80 characters.  Many Coq IDE setups divide the screen in half vertically and use only half to display source code, so more than 80 characters can be genuinely hard to read on a laptop.    Whitespace and indentation #    No trailing whitespace.\n  Spaces, not tabs.\n  Files should end with a newline.\n Many editors do this automatically on save.    Colons may be either \u0026ldquo;English-spaced\u0026rdquo;, with no space before the colon and one space after (x: nat) or \u0026ldquo;French-spaced\u0026rdquo;, with one space before and after (x : nat).\n  Default indentation is 2 spaces.\n Keeping this small prevents complex proofs from being indented ridiculously far, and matches IDE defaults.    Use 2-space indents if inserting a line break immediately after:\n Proof. fun \u0026lt;...\u0026gt; =\u0026gt; forall \u0026lt;...\u0026gt;, exists \u0026lt;....\u0026gt;,    The style for indenting arguments in function application depends on where you make a line break. If you make the line break immediately after the function name, use a 2-space indent. However, if you make it after one or more arguments, align the next line with the first argument:\n(Z.pow 1 2) (Z.pow 1 2 3 4 5 6)   Inductive cases should not be indented. Example:\nInductive Foo : Type := | FooA : Foo | FooB : Foo .   match or lazymatch cases should line up with the \u0026ldquo;m\u0026rdquo; in match or \u0026ldquo;l\u0026rdquo; in lazymatch, as in the following examples:\nmatch x with | 3 =\u0026gt; true | _ =\u0026gt; false end. lazymatch x with | 3 =\u0026gt; idtac | _ =\u0026gt; fail \u0026#34;Not equal to 3:\u0026#34; x end. repeat match goal with | _ =\u0026gt; progress subst | _ =\u0026gt; reflexivity end. do 2 lazymatch goal with | |- context [eq] =\u0026gt; idtac end.   Definitions and Fixpoints #   It\u0026rsquo;s okay to leave the return type of Definition\u0026rsquo;s and Fixpoint\u0026rsquo;s implicit (e.g. Definition x := 5 instead of Definition x : nat := 5) when the type is very simple or obvious (for instance, the definition is in a file which deals exclusively with operations on Z).  Inductives #    The . ending an Inductive can be either on the same line as the last case or on its own line immediately below. That is, both of the following are acceptable:\nInductive Foo : Type := | FooA : Foo | FooB : Foo . Inductive Foo : Type := | FooA : Foo | FooB : Foo.   Lemma/Theorem statements #   Generally, use Theorem for the most important, top-level facts you prove and Lemma for everything else. Insert a line break after the colon in the lemma statement. Insert a line break after the comma for forall or exist quantifiers. Implication arrows (-\u0026gt;) should share a line with the previous hypothesis, not the following one. There is no need to make a line break after every -\u0026gt;; short preconditions may share a line.  Proofs and tactics #    Use the Proof command (lined up vertically with Lemma or Theorem it corresponds to) to open a proof, and indent the first line after it 2 spaces.\n  Very small proofs (where Proof. \u0026lt;tactics\u0026gt; Qed. is \u0026lt;= 80 characters) can go all in one line.\n  When ending a proof, align the ending statement (Qed, Admitted, etc.) with Proof.\n  Avoid referring to autogenerated names (e.g. =H0=, n0). It\u0026rsquo;s okay to let Coq generate these names, but you should not explicitly refer to them in your proof. So intros; my_solver is fine, but intros; apply H1; my_solver is not fine.\n You can force a non-autogenerated name by either putting the variable before the colon in the lemma statement (Lemma foo x : ... instead of Lemma foo : forall x, ...), or by passing arguments to intros (e.g. =intros ? x= to name the second argument x)    This way, the proof won\u0026rsquo;t break when new hypotheses are added or autogenerated variable names change.\n  Use curly braces {} for subgoals, instead of bullets.\n  Never write tactics with more than one subgoal focused. This can make the proof very confusing to step through! If you have more than one subgoal, use curly braces.\n  Consider adding a comment after the opening curly brace that explains what case you\u0026rsquo;re in (see example).\n This is not necessary for small subgoals but can help show the major lines of reasoning in large proofs.    If invoking a tactic that is expected to return multiple subgoals, use [ | ... | ] before the . to explicitly specify how many subgoals you expect.\n Examples: split; [ | ]. induction z; [ | | ]. This helps make code more maintainable, because it fails immediately if your tactic no longer solves as many subgoals as expected (or unexpectedly solves more).    If invoking a string of tactics (composed by ;) that will break the goal into multiple subgoals and then solve all but one, still use [ ] to enforce that all but one goal is solved.\n Example: split; try lia; [ ].    Tactics that consist only of repeat-ing a procedure (e.g. repeat match, repeat first) should factor out a single step of that procedure a separate tactic called \u0026lt;tactic name\u0026gt;_step, because the single-step version is much easier to debug. For instance:\nLtac crush_step := match goal with | _ =\u0026gt; progress subst | _ =\u0026gt; reflexivity end. Ltac crush := repeat crush_step.   Naming #    Helper proofs about standard library datatypes should go in a module that is named to match the standard library module (see example).\n This makes the helper proofs look like standard-library ones, which is helpful for categorizing them if they\u0026rsquo;re genuinely at the standard-library level of abstraction.    Names of modules should start with capital letters.\n  Names of inductives and their constructors should start with capital letters.\n  Names of other definitions/lemmas should be snake case.\n  Example #  A small standalone Coq file that exhibits many of the style points.\n(* * Vericert: Verified high-level synthesis. * Copyright (C) 2021 Name \u0026lt;email@example.com\u0026gt; * * \u0026lt;License...\u0026gt; *) Require Import Coq.Lists.List. Require Import Coq.micromega.Lia. Require Import Coq.ZArith.ZArith. Import ListNotations. Local Open Scope Z_scope. (* Helper proofs about standard library integers (Z) go within [Module Z] so that they match standard-library Z lemmas when used. *) Module Z. Lemma pow_3_r x : x ^ 3 = x * x * x. Proof. lia. Qed. (* very short proofs can go all on one line *) Lemma pow_4_r x : x ^ 4 = x * x * x * x. Proof. change 4 with (Z.succ (Z.succ (Z.succ (Z.succ 0)))). repeat match goal with | _ =\u0026gt; rewrite Z.pow_1_r | _ =\u0026gt; rewrite Z.pow_succ_r by lia | |- context [x * (?a * ?b)] =\u0026gt; replace (x * (a * b)) with (a * b * x) by lia | _ =\u0026gt; reflexivity end. Qed. End Z. (* Now we can access the lemmas above as Z.pow_3_r and Z.pow_4_r, as if they were in the ZArith library! *) Definition bar (x y : Z) := x ^ (y + 1). (* example with a painfully manual proof to show case formatting *) Lemma bar_upper_bound : forall x y a, 0 \u0026lt;= x \u0026lt;= a -\u0026gt; 0 \u0026lt;= y -\u0026gt; 0 \u0026lt;= bar x y \u0026lt;= a ^ (y + 1). Proof. (* avoid referencing autogenerated names by explicitly naming variables *) intros x y a Hx Hy. revert y Hy x a Hx. (* explicitly indicate # subgoals with [ | ... | ] if \u0026gt; 1 *) cbv [bar]; refine (natlike_ind _ _ _); [ | ]. { (* y = 0 *) intros; lia. } { (* y = Z.succ _ *) intros. rewrite Z.add_succ_l, Z.pow_succ_r by lia. split. { (* 0 \u0026lt;= bar x y *) apply Z.mul_nonneg_nonneg; [ lia | ]. apply Z.pow_nonneg; lia. } { (* bar x y \u0026lt; a ^ y *) rewrite Z.pow_succ_r by lia. apply Z.mul_le_mono_nonneg; try lia; [ apply Z.pow_nonneg; lia | ]. (* For more flexible proofs, use match statements to find hypotheses rather than referring to them by autogenerated names like H0. In this case, we\u0026#39;ll take any hypothesis that applies to and then solves the goal. *) match goal with H : _ |- _ =\u0026gt; apply H; solve [auto] end. } } Qed. (* Put notations in a separate module or file so that importers can decide whether or not to use them. *) Module BarNotations. Infix \u0026#34;#\u0026#34; := bar (at level 40) : Z_scope. Notation \u0026#34;x \u0026#39;##\u0026#39;\u0026#34; := (bar x x) (at level 40) : Z_scope. End BarNotations. "});index.add({'id':2,'href':'/docs/','title':"Docs",'section':"Vericert",'content':"Vericert translates C code into a hardware description language called Verilog, which can then be synthesised into hardware, to be placed onto a field-programmable gate array (FPGA) or application-specific integrated circuit (ASIC).\n\n  Figure 1: Current design of Vericert, where HTL is an intermediate language representing a finite state machine with data-path (FSMD) and Verilog is the target language.\n  The design shown in Figure 1 shows how Vericert leverages an existing verified C compiler called CompCert to perform this translation.\n"});index.add({'id':3,'href':'/docs/using-vericert/','title':"Using Vericert",'section':"Docs",'content':"Vericert can be used to translate a subset of C into Verilog. As a simple example, consider the following C file (main.c):\nvoid matrix_multiply(int first[2][2], int second[2][2], int multiply[2][2]) { int sum = 0; for (int c = 0; c \u0026lt; 2; c++) { for (int d = 0; d \u0026lt; 2; d++) { for (int k = 0; k \u0026lt; 2; k++) { sum = sum + first[c][k]*second[k][d]; } multiply[c][d] = sum; sum = 0; } } } int main() { int f[2][2] = {{1, 2}, {3, 4}}; int s[2][2] = {{5, 6}, {7, 8}}; int m[2][2] = {{0, 0}, {0, 0}}; matrix_multiply(f, s, m); return m[1][1]; } It can be compiled using the following command, assuming that vericert is somewhere on the path.\nvericert main.c -o main.v The Verilog file contains a top-level test-bench, which can be given to any Verilog simulator to simulate the hardware, which should give the same result as executing the C code. Using Icarus Verilog as an example:\niverilog -o main_v main.v When executing, it should therefore print the following:\n$ ./main_v finished: 50 This gives the same result as executing the C in the following way:\n$ gcc -o main_c main.c $ ./main_c $ echo $? 50 "});})();